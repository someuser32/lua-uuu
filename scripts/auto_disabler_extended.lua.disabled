local class = require("lib/middleclass")

require("lib/lib")

local ScriptAPI = require("lib/script")()

local AutoDisablerExtended = class("AutoDisablerExtended")

function AutoDisablerExtended:initialize()
	self.path = {"General", "Auto Disabler (Extended)"}

	self.disable_abilities = {
		{"item_orchid", "Orchid Malevolence", "panorama/images/items/orchid_png.vtex_c", true, true},
		{"item_bloodthorn", "Bloodthorn", "panorama/images/items/bloodthorn_png.vtex_c", true, true},
		{"item_sheepstick", "Scythe of Vyse", "panorama/images/items/sheepstick_png.vtex_c", true, true},
		{"item_cyclone", "Eul's Scepter of Divinity", "panorama/images/items/cyclone_png.vtex_c", true, true},
		{"item_abyssal_blade", "Abyssal Blade", "panorama/images/items/abyssal_blade_png.vtex_c", true, true},
		{"item_book_of_shadows", "Book of Shadows", "panorama/images/items/book_of_shadows_png.vtex_c", false, true},
		{"item_wind_waker", "Wind Waker", "panorama/images/items/wind_waker_png.vtex_c", false, true},
		{"lion_voodoo", "Hex (Lion)", "panorama/images/spellicons/lion_voodoo_png.vtex_c", true, true},
		{"shadow_shaman_voodoo", "Hex (Shadow Shaman)", "panorama/images/spellicons/shadow_shaman_voodoo_png.vtex_c", true, true},
		{"rubick_telekinesis", "Telekinesis", "panorama/images/spellicons/rubick_telekinesis_png.vtex_c", true, true},
		{"skywrath_mage_ancient_seal", "Ancient Seal", "panorama/images/spellicons/skywrath_mage_ancient_seal_png.vtex_c", true, true},
		{"dragon_knight_dragon_tail", "Dragon Tail", "panorama/images/spellicons/dragon_knight_dragon_tail_png.vtex_c", true, true},
		{"invoker_cold_snap", "Cold Snap", "panorama/images/spellicons/invoker_cold_snap_png.vtex_c", true, true},
		{"invoker_tornado", "Tornado", "panorama/images/spellicons/invoker_tornado_png.vtex_c", true, false},
		{"obsidian_destroyer_astral_imprisonment", "Astral Imprisonment", "panorama/images/spellicons/obsidian_destroyer_astral_imprisonment_png.vtex_c", true, true},
		{"grimstroke_ink_creature", "Phantom's Embrace", "panorama/images/spellicons/grimstroke_ink_creature_png.vtex_c", true, true},
		{"lich_sinister_gaze", "Sinister Gaze", "panorama/images/spellicons/lich_sinister_gaze_png.vtex_c", true, true},
		{"bane_nightmare", "Nightmare", "panorama/images/spellicons/bane_nightmare_png.vtex_c", false, true},
		{"disruptor_glimpse", "Glimpse", "panorama/images/spellicons/disruptor_glimpse_png.vtex_c", true, true},
		{"shadow_demon_disruption", "Disruption", "panorama/images/spellicons/shadow_demon_disruption_png.vtex_c", true, true},
		{"lone_druid_savage_roar", "Savage Roar", "panorama/images/spellicons/lone_druid_savage_roar_png.vtex_c", false, false},
	}

	self.enemy_abilities = {
		{"item_blink", "Blink Dagger", "panorama/images/items/blink_png.vtex_c", true, false},
		{"axe_berserkers_call", "Berserker's Call", "panorama/images/spellicons/axe_berserkers_call_png.vtex_c", true, true},
		{"tidehunter_ravage", "Ravage", "panorama/images/spellicons/tidehunter_ravage_png.vtex_c", true, true},
		{"enigma_black_hole", "Black Hole", "panorama/images/spellicons/enigma_black_hole_png.vtex_c", true, true},
		{"magnataur_reverse_polarity", "Reverse Polarity", "panorama/images/spellicons/magnataur_reverse_polarity_png.vtex_c", true, true},
		{"legion_commander_duel", "Duel", "panorama/images/spellicons/legion_commander_duel_png.vtex_c", true, true},
		{"beastmaster_primal_roar", "Primal Roar", "panorama/images/spellicons/beastmaster_primal_roar_png.vtex_c", true, true},
		{"treant_overgrowth", "Overgrowth", "panorama/images/spellicons/treant_overgrowth_png.vtex_c", true, true},
		{"faceless_void_chronosphere", "Chronosphere", "panorama/images/spellicons/faceless_void_chronosphere_png.vtex_c", true, true},
		{"batrider_flaming_lasso", "Flaming Lasso", "panorama/images/spellicons/batrider_flaming_lasso_png.vtex_c", true, true},
		{"bane_fiends_grip", "Fiend's Grip", "panorama/images/spellicons/bane_fiends_grip_png.vtex_c", true, true},
		{"faceless_void_time_walk", "Time Walk", "panorama/images/spellicons/faceless_void_time_walk_png.vtex_c", true, nil},
		{"storm_spirit_ball_lightning", "Ball Lightning", "panorama/images/spellicons/storm_spirit_ball_lightning_png.vtex_c", true, true},
		{"void_spirit_astral_step", "Astral Step", "panorama/images/spellicons/void_spirit_astral_step_png.vtex_c", true, nil},
		{"void_spirit_dissimilate", "Dissimilate", "panorama/images/spellicons/void_spirit_dissimilate_png.vtex_c", true, nil},
		{"doom_bringer_doom", "Doom", "panorama/images/spellicons/doom_bringer_doom_png.vtex_c", true, true},
		{"juggernaut_omni_slash", "Omnislash", "panorama/images/spellicons/juggernaut_omni_slash_png.vtex_c", true, true},
		{"life_stealer_infest", "Infest", "panorama/images/spellicons/life_stealer_infest_png.vtex_c", true, true},
		{"monkey_king_wukongs_command", "Wukong's Command", "panorama/images/spellicons/monkey_king_wukongs_command_png.vtex_c", false, true},
		{"naga_siren_song_of_the_siren", "Song of the Siren", "panorama/images/spellicons/naga_siren_song_of_the_siren_png.vtex_c", true, true},
		{"pangolier_gyroshell", "Rolling Thunder", "panorama/images/spellicons/pangolier_gyroshell_png.vtex_c", true, true},
		{"phantom_assassin_phantom_strike", "Phantom Strike", "panorama/images/spellicons/phantom_assassin_phantom_strike_png.vtex_c", true, nil},
		{"primal_beast_pulverize", "Pulverize", "panorama/images/spellicons/primal_beast_pulverize_png.vtex_c", true, nil},
		{"pudge_dismember", "Dismember", "panorama/images/spellicons/pudge_dismember_png.vtex_c", true, nil},
		{"queenofpain_blink", "Blink (Queen of Pain)", "panorama/images/spellicons/queenofpain_blink_png.vtex_c", true, nil},
		{"riki_tricks_of_the_trade", "Tricks of the Trade", "panorama/images/spellicons/riki_tricks_of_the_trade_png.vtex_c", true, true},
		{"sandking_epicenter", "Epicenter", "panorama/images/spellicons/sandking_epicenter_png.vtex_c", true, true},
		{"nevermore_requiem", "Requiem of Souls", "panorama/images/spellicons/nevermore_requiem_png.vtex_c", true, true},
		{"slardar_slithereen_crush", "Slithreen Crush", "panorama/images/spellicons/slardar_slithereen_crush_png.vtex_c", false, true},
		{"snapfire_mortimer_kisses", "Mortimer Kisses", "panorama/images/spellicons/snapfire_mortimer_kisses_png.vtex_c", true, nil},
		{"spirit_breaker_nether_strike", "Nether Strike", "panorama/images/spellicons/spirit_breaker_nether_strike_png.vtex_c", false, true},
		{"terrorblade_sunder", "Sunder", "panorama/images/spellicons/terrorblade_sunder_png.vtex_c", true, true},
		{"undying_tombstone", "Tombstone", "panorama/images/spellicons/undying_tombstone_png.vtex_c", true, true},
		{"vengefulspirit_nether_swap", "Nether Swap", "panorama/images/spellicons/vengefulspirit_nether_swap_png.vtex_c", true, true},
		{"weaver_time_lapse", "Time Lapse", "panorama/images/spellicons/weaver_time_lapse_png.vtex_c", true, true},
		{"winter_wyvern_winters_curse", "Winter's Curse", "panorama/images/spellicons/winter_wyvern_winters_curse_png.vtex_c", true, true},
		{"antimage_blink", "Blink (Anti-Mage)", "panorama/images/spellicons/antimage_blink_png.vtex_c", false, nil},
		{"centaur_hoof_stomp", "Hoof Stomp", "panorama/images/spellicons/centaur_hoof_stomp_png.vtex_c", false, nil},
	}

	self.invis_options = {
		"Always",
		"If visible",
		"If true sighted",
		"Never",
	}

	self.anti_overwatch_delay_visible = 0.2
	self.anti_overwatch_delay_fow = 0.3
	self.anti_overwatch_camera_options = {
		"Always",
		"If controlled unit near camera",
		"If controlled unit and ally near camera",
		"If caster near camera",
	}

	self.loaded_icons = {
		aggressive_disable=Renderer.LoadImage("~/MenuIcons/enemy_evil.png")
	}

	self.disable_abilities_multiselect = {}
	for _, disable_ability in pairs(self.disable_abilities) do
		table.insert(self.disable_abilities_multiselect, {disable_ability[1], disable_ability[3], disable_ability[4]})
		self.loaded_icons[disable_ability[1]] = Renderer.LoadImage(disable_ability[3])
	end

	self.enemy_abilities_multiselect = {}
	for _, enemy_ability in pairs(self.enemy_abilities) do
		table.insert(self.enemy_abilities_multiselect, {enemy_ability[1], enemy_ability[3], enemy_ability[4]})
		self.loaded_icons[enemy_ability[1]] = Renderer.LoadImage(enemy_ability[3])
	end

	self.auto_disabler_disable_abilities = {}
	self.auto_disabler_disable_abilities_global = {}

	self.auto_disabler_enable = UI_LIB:create_bool(self.path, "Enable", false)

	self.auto_disabler_disable_abilities_order = UI_LIB:create_multiselect(self.path, "Your abilities", self.disable_abilities_multiselect, false)

	self:CreateDisableAbility(table.combine(self.path, {"Settings", "Abilities", "Global"}), "global", true, "~/MenuIcons/globe_world.png")

	for _, disable_ability in pairs(table.combine(self.disable_abilities)) do
		self:CreateDisableAbility(table.combine(self.path, {"Settings", "Abilities", disable_ability[2]}), disable_ability[1], disable_ability[5], disable_ability[3])
	end

	UI_LIB:set_tab_icon(table.combine(self.path, {"Settings", "Abilities"}), "~/MenuIcons/Dota/spell_book.png")

	self.auto_disabler_invis_options = UI_LIB:create_combo(table.combine(self.path, {"Settings", "Conditions"}), "Invisibility", self.invis_options, 2)
	self.auto_disabler_invis_options:set_icon("~/MenuIcons/eye_dashed.png")
	self.auto_disabler_ignore_channelling = UI_LIB:create_bool(table.combine(self.path, {"Settings", "Conditions"}), "Interrupt channelings", false)
	self.auto_disabler_ignore_channelling:set_icon("~/MenuIcons/open_book.png")
	UI_LIB:set_tab_icon(table.combine(self.path, {"Settings", "Conditions"}), "~/MenuIcons/Lists/true_false.png")

	self.auto_disabler_trigger_chance = UI_LIB:create_slider(table.combine(self.path, {"Settings", "Randomization"}), "Trigger chance", 1, 100, 100)
	self.auto_disabler_trigger_chance:set_icon("~/MenuIcons/counter_simple.png")
	self.auto_disabler_min_delay = UI_LIB:create_slider(table.combine(self.path, {"Settings", "Randomization"}), "Minimal delay", 0, 0.5, 0)
	self.auto_disabler_min_delay:set_icon("~/MenuIcons/Time/timer_def.png")
	self.auto_disabler_max_delay = UI_LIB:create_slider(table.combine(self.path, {"Settings", "Randomization"}), "Maximum delay", 0, 0.5, 0)
	self.auto_disabler_max_delay:set_icon("~/MenuIcons/Time/timer_def.png")
	self.auto_disabler_delay_less_than_cast = UI_LIB:create_bool(table.combine(self.path, {"Settings", "Randomization"}), "Always delay < castpoint", true)
	self.auto_disabler_delay_less_than_cast:set_tip("Ignore delay if enemy ability's cast point is less than delay + your abiltiy cast point\nWarning! This option ignores Anti-Overwatch!\n[OVERWATCH RISK]")
	self.auto_disabler_delay_less_than_cast:set_icon("~/MenuIcons/Time/sand_time.png")
	self.auto_disabler_instant_enemies = UI_LIB:create_enemymultiselect(table.combine(self.path, {"Settings", "Randomization"}), "Instant enemies", false, false, true)
	self.auto_disabler_instant_enemies:set_tip("[Rage mode]\n- Selected enemies will be disabled instantly ignoring any delays\n- Warning! This option ignores Anti-Overwatch\n[OVERWATCH RISK]")
	self.auto_disabler_instant_enemies:set_icon("~/MenuIcons/Time/time_meet.png")
	UI_LIB:set_tab_icon(table.combine(self.path, {"Settings", "Randomization"}), "~/MenuIcons/ichange_v1.png")

	self.auto_disabler_aggressive_range = UI_LIB:create_slider(table.combine(self.path, "Settings"), "Aggressive range", 100, 1200, 900)
	self.auto_disabler_aggressive_range:set_icon("~/MenuIcons/enemy_evil.png")
	self.auto_disabler_aggressive_range:set_tip("[Rage mode]\n- Disables selected enemies within aggressive range (but not farther than ability's cast range)\n- Ignores any randomization\n- Warning! This option ignores Anti-Overwatch\n[OVERWATCH RISK]")

	self.auto_disabler_anti_overwatch_delay = UI_LIB:create_bool(table.combine(self.path, {"Settings", "Anti-Overwatch"}), "Delay", true)
	self.auto_disabler_anti_overwatch_delay:set_tip("[Legit mode]\n- "..tostring(self.anti_overwatch_delay_visible).."s delay if enemy triggered NOT from Fog of War\n- "..tostring(self.anti_overwatch_delay_fow).."s delay if enemy triggered from Fog of War\n- Disabling this might trigger Auto-Overwatch algorithm\n[OVERWATCH RISK]")
	self.auto_disabler_anti_overwatch_delay:set_icon("~/MenuIcons/Time/time_span.png")
	self.auto_disabler_anti_overwatch_camera = UI_LIB:create_combo(table.combine(self.path, {"Settings", "Anti-Overwatch"}), "Camera options", self.anti_overwatch_camera_options, 4)
	self.auto_disabler_anti_overwatch_camera:set_tip("[Legit mode]\n[Always] - always disable enemy\n[If controlled unit near camera] - if your controlled unit (Tempest Double etc) near server camera pos\n[If controlled unit and ally near camera] - if your controlled unit (Tempest Double etc) and ally near server camera pos\n[If caster near camera] - if your any caster (including you, controlling units and allies) near server camera pos\n- Changing value from \"If caster near camera\" might be not-legit for Overwatch\n[OVERWATCH RISK]")
	self.auto_disabler_anti_overwatch_camera:set_icon("~/MenuIcons/binoculars_filled.png")
	UI_LIB:set_tab_icon(table.combine(self.path, {"Settings", "Anti-Overwatch"}), "~/MenuIcons/robot.png")

	self.auto_disabler_notifications = UI_LIB:create_bool(table.combine(self.path, "Settings"), "Notification", true)
	self.auto_disabler_notifications:set_icon("~/MenuIcons/Notifications/alarm.png")

	UI_LIB:set_tab_icon(self.path, "~/MenuIcons/silent.png")
	UI_LIB:set_tab_icon(table.combine(self.path, "Settings"), "~/MenuIcons/utils_wheel.png")

	self.listeners = {}

	if self:IsEnabled() then
		self.listeners["AbilityUsageHeroEnemy"] = true
		self.listeners["HeroVisibilityEnemy"] = true
	end
end

function AutoDisablerExtended:CreateDisableAbility(whereAt, ability_name, is_targeted, icon)
	if ability_name ~= "global" then
		self.auto_disabler_disable_abilities[ability_name.."_use_global"] = UI_LIB:create_bool(whereAt, "Ignore global settings", false)
	end
	self.auto_disabler_disable_abilities[ability_name.."_trigger"] = UI_LIB:create_multiselect(whereAt, "Enemy's abilities", self.enemy_abilities_multiselect, false)
	self.auto_disabler_disable_abilities[ability_name.."_trigger_enemies"] = {}
	for _, enemy_ability in pairs(self.enemy_abilities) do
		if string.startswith(enemy_ability[1], "item_") then
			self.auto_disabler_disable_abilities[ability_name.."_trigger_enemies"][enemy_ability[1]] = UI_LIB:create_enemymultiselect(whereAt, enemy_ability[2].." Enemies", false, true, true)
			self.auto_disabler_disable_abilities[ability_name.."_trigger_enemies"][enemy_ability[1]]:set_icon(enemy_ability[3])
		end
	end
	if is_targeted then
		self.auto_disabler_disable_abilities[ability_name.."_linken_breaker"] = LinkenBreaker:create_option(whereAt, nil, nil, true, ability_name)
		self.auto_disabler_disable_abilities[ability_name.."_spell_reflect"] = SpellReflect:create_option(whereAt)
	end
	self.auto_disabler_disable_abilities[ability_name.."_additional_range"] = UI_LIB:create_slider(whereAt, "Additional range", 0, 450, 75)
	self.auto_disabler_disable_abilities[ability_name.."_additional_range"]:set_icon("~/MenuIcons/radius.png")
	self.auto_disabler_disable_abilities[ability_name.."_instant_mode"] = UI_LIB:create_bool(whereAt, "Instant mode", false)
	self.auto_disabler_disable_abilities[ability_name.."_instant_mode"]:set_tip("[Rage mode]\n- Ignores any delays for this ability\n- Warning! This option ignores Anti-Overwatch\n[OVERWATCH RISK]")
	self.auto_disabler_disable_abilities[ability_name.."_instant_mode"]:set_icon("~/MenuIcons/red_square.png")
	self.auto_disabler_disable_abilities[ability_name.."_aggressive_enemies"] = UI_LIB:create_enemymultiselect(whereAt, "Aggressive enemies", false, false, true)
	self.auto_disabler_disable_abilities[ability_name.."_aggressive_enemies"]:set_tip("[Rage mode]\n- Disables selected enemies within aggressive range (but not farther than ability's cast range)\n- Ignores any randomization\n- Warning! This option ignores Anti-Overwatch\n[OVERWATCH RISK]")
	self.auto_disabler_disable_abilities[ability_name.."_aggressive_enemies"]:set_icon("~/MenuIcons/enemy_evil.png")
	self.auto_disabler_disable_abilities[ability_name.."_allies"] = UI_LIB:create_onlyallymultiselect(whereAt, "Allies", false, false, true)
	self.auto_disabler_disable_abilities[ability_name.."_allies"]:set_tip("Ally must give shared control access")
	self.auto_disabler_disable_abilities[ability_name.."_allies"]:set_icon("~/MenuIcons/add_user.png")
	UI_LIB:set_tab_icon(whereAt, icon)
end

function AutoDisablerExtended:IsEnabled()
	return self.auto_disabler_enable:get_value()
end

function AutoDisablerExtended:OnUpdate()
	local tick = self:GetTick()
	if tick % 5 == 0 then
		for _, hero in pairs(CHeroes.GetEnemies()) do
			if hero:IsVisible() then
				self:Trigger(nil, nil, hero)
			end
		end
	end
end

function AutoDisablerExtended:OnNPCUsedAbility(ability)
	local caster = ability:GetCaster()
	local ability_name = ability:GetName(true)
	for _, ability_info in pairs(self.enemy_abilities) do
		if ability_info[1] == ability_name then
			if ability_info[5] == true then
				break
			end
			self:Trigger(ability, false, caster)
			break
		end
	end
end

function AutoDisablerExtended:OnNPCPhaseAbility(ability)
	local caster = ability:GetCaster()
	local ability_name = ability:GetName(true)
	for _, ability_info in pairs(self.enemy_abilities) do
		if ability_info[1] == ability_name then
			if ability_info[5] == false then
				break
			end
			self:Trigger(ability, true, caster)
			break
		end
	end
end

function AutoDisablerExtended:GetAbilityInfo(ability_name)
	if self.auto_disabler_disable_abilities[ability_name.."_use_global"] == nil then
		return
	end
	if not self.auto_disabler_disable_abilities[ability_name.."_use_global"]:get_value() then
		ability_name = "global"
	end
	return {
		enemy_abilities=self.auto_disabler_disable_abilities[ability_name.."_trigger"],
		enemies=self.auto_disabler_disable_abilities[ability_name.."_trigger_enemies"],
		linken_breaker_option=self.auto_disabler_disable_abilities[ability_name.."_linken_breaker"],
		spell_reflect_option=self.auto_disabler_disable_abilities[ability_name.."_spell_reflect"],
		additional_range=self.auto_disabler_disable_abilities[ability_name.."_additional_range"],
		aggressive_enemies=self.auto_disabler_disable_abilities[ability_name.."_aggressive_enemies"],
		instant_mode=self.auto_disabler_disable_abilities[ability_name.."_instant_mode"],
		allies_option=self.auto_disabler_disable_abilities[ability_name.."_allies"],
	}
end

function AutoDisablerExtended:IsValidAbilityToDisable(ability_name)
	local ability_info = self:GetAbilityInfo(ability_name)
	return ability_info ~= nil
end

function AutoDisablerExtended:CanBeTriggeredByAbility(ability_name, enemy_ability_name)
	local ability_info = self:GetAbilityInfo(ability_name)
	if ability_info["enemy_abilities"] == nil then return true end
	return ability_info["enemy_abilities"]:is_selected(enemy_ability_name)
end

function AutoDisablerExtended:CanBeTriggeredByAbilityAndEnemy(ability_name, enemy_ability)
	local ability_info = self:GetAbilityInfo(ability_name)
	local enemy_ability_name = enemy_ability:GetName(true)
	if not self:CanBeTriggeredByAbility(ability_name, enemy_ability_name) then
		return false
	end
	if ability_info["enemies"][enemy_ability_name] == nil then
		return true
	end
	return ability_info["enemies"][enemy_ability_name]:is_selected(enemy_ability:GetCaster():GetUnitName())
end

function AutoDisablerExtended:GetLinkenBreakerForDisableAbility(ability_name)
	if not self:IsValidAbilityToDisable(ability_name) then
		return
	end
	if self.auto_disabler_disable_abilities[ability_name.."_linken_breaker"] == nil then
		return
	end
	local ability_info = self:GetAbilityInfo(ability_name)
	return ability_info["linken_breaker_option"]
end

function AutoDisablerExtended:GetSpellReflectForDisableAbility(ability_name)
	if not self:IsValidAbilityToDisable(ability_name) then
		return
	end
	if self.auto_disabler_disable_abilities[ability_name.."_spell_reflect"] == nil then
		return
	end
	local ability_info = self:GetAbilityInfo(ability_name)
	return ability_info["spell_reflect_option"]
end

function AutoDisablerExtended:GetAdditionalRangeForDisableAbility(ability_name)
	local ability_info = self:GetAbilityInfo(ability_name)
	if ability_info["additional_range"] == nil then return 0 end
	return ability_info["additional_range"]:get_value()
end

function AutoDisablerExtended:IsInstantAbility(ability_name)
	local ability_info = self:GetAbilityInfo(ability_name)
	if ability_info["instant_mode"] == nil then return false end
	return ability_info["instant_mode"]:get_value()
end

function AutoDisablerExtended:IsAggressiveEnemy(ability_name, enemy_name)
	local ability_info = self:GetAbilityInfo(ability_name)
	if ability_info["aggressive_enemies"] == nil then return false end
	return ability_info["aggressive_enemies"]:is_selected(enemy_name)
end

function AutoDisablerExtended:CanAllyDisableByAbility(ability_name, ally_name)
	local ability_info = self:GetAbilityInfo(ability_name)
	if ability_info["allies_option"] == nil then return false end
	return ability_info["allies_option"]:is_selected(ally_name)
end

function AutoDisablerExtended:CanDisableConsideringCamera(caster, enemy)
	local camera_behavior = self.auto_disabler_anti_overwatch_camera:get_selected_index()
	local caster_position = caster:GetAbsOrigin()
	local enemy_position = enemy:GetAbsOrigin()
	local is_local_hero = CHero.GetLocal() == caster
	local is_ally = CPlayer.GetLocal():GetPlayerID() ~= caster:GetPlayerID()
	local camera_distance = 1200
	local camera_legit_threshold = 250
	local camera_position = Humanizer.GetServerCameraPos()
	if camera_behavior == 1 then
		return true
	elseif camera_behavior == 2 then
		if is_local_hero or is_ally then
			return true
		end
		return Humanizer.IsInServerCameraBounds(caster_position) or Humanizer.IsInServerCameraBounds(enemy_position)
				or ((camera_position - caster_position):Length2D() < camera_distance + camera_legit_threshold) or ((camera_position - enemy_position):Length2D() < camera_distance + 300)
	elseif camera_behavior == 3 then
		if is_local_hero then
			return true
		end
		return Humanizer.IsInServerCameraBounds(caster_position) or Humanizer.IsInServerCameraBounds(enemy_position)
				or ((camera_position - caster_position):Length2D() < camera_distance + camera_legit_threshold) or ((camera_position - enemy_position):Length2D() < camera_distance + 300)
	elseif camera_behavior == 4 then
		return Humanizer.IsInServerCameraBounds(caster_position) or Humanizer.IsInServerCameraBounds(enemy_position)
				or ((camera_position - caster_position):Length2D() < camera_distance + camera_legit_threshold) or ((camera_position - enemy_position):Length2D() < camera_distance + 300)
	end
	return true
end

function AutoDisablerExtended:GetUsableAbilitiesToDisable(hero, enemy_ability, enemy)
	if not self:CanDisableConsideringCamera(hero, enemy) then
		return {}
	end
	if not self.auto_disabler_ignore_channelling:get_value() and hero:IsChannellingAbility() then
		return {}
	end
	if hero:IsInvisible() then
		local invis_option = self.auto_disabler_invis_options:get_selected_index()
		if invis_option == 2 then
			if not hero:IsVisibleToEnemies() then
				return {}
			end
		elseif invis_option == 3 then
			if not hero:IsTrueSight() then
				return {}
			end
		elseif invis_option == 4 then
			return {}
		end
	end
	local usable_abilities = {}
	local distance = (enemy:GetAbsOrigin() - hero:GetAbsOrigin()):Length2D()
	local aggressive_range = self.auto_disabler_aggressive_range:get_value()
	if enemy_ability == nil then
		if distance > aggressive_range then
			return {}
		end
	end
	local hero_name = hero:GetUnitName()
	local enemy_name = enemy:GetUnitName()
	local is_local_hero = CPlayer.GetLocal():GetPlayerID() == hero:GetPlayerID()
	local is_enemy_bkb = enemy:IsDebuffImmune()
	for _, ability_name in pairs(self.auto_disabler_disable_abilities_order:get_value()) do
		if (enemy_ability ~= nil and {self:CanBeTriggeredByAbilityAndEnemy(ability_name, enemy_ability)} or {self:IsAggressiveEnemy(ability_name, enemy_name)})[1] then
			if is_local_hero or self:CanAllyDisableByAbility(ability_name, hero_name) then
				local ability = string.startswith(ability_name, "item_") and hero:GetItemByName(ability_name, 2) or hero:GetAbility(ability_name)
				if ability ~= nil and ability:CanCast() and (not is_enemy_bkb or ability:PiercesBKB()) then
					local is_targeted = ability:HasBehavior(Enum.AbilityBehavior.DOTA_ABILITY_BEHAVIOR_UNIT_TARGET)
					if not is_targeted or not enemy:IsAbsorbsSpells() then
						local cast_range = ability:GetCastRange()
						if cast_range == 0 then
							cast_range = ability:GetRadius()
						end
						if cast_range + self:GetAdditionalRangeForDisableAbility(ability_name) >= distance then
							local linken_breaker_option = self:GetLinkenBreakerForDisableAbility(ability_name)
							if linken_breaker_option == nil or LinkenBreaker:can_use(hero, enemy, linken_breaker_option, nil, ability_name) then
								local spell_reflect_option = self:GetSpellReflectForDisableAbility(ability_name)
								if spell_reflect_option == nil or SpellReflect:can_use(ability, enemy, spell_reflect_option) then
									table.insert(usable_abilities, ability)
								end
							end
						end
					end
				end
			end
		end
	end
	return usable_abilities
end

function AutoDisablerExtended:Trigger(ability, isPhase, enemy)
	if not self:IsEnabled() then return end
	local delay = 0
	if ability ~= nil then
		if not RollPercentage(self.auto_disabler_trigger_chance:get_value()) then return end
		delay = math.randomFloat(self.auto_disabler_min_delay:get_value(), self.auto_disabler_max_delay:get_value())
		if self.auto_disabler_anti_overwatch_delay:get_value() then
			delay = delay + (self:WasHeroVisible(ability:GetCaster()) and self.anti_overwatch_delay_visible or self.anti_overwatch_delay_fow)
		end
		if isPhase and self.auto_disabler_delay_less_than_cast:get_value() then
			delay = math.max(math.min(delay, ability:GetCastPoint()-GetPingDelay()*2-0.175), 0)
		end
		if self.auto_disabler_instant_enemies:is_selected(enemy:GetUnitName()) then
			delay = 0
		end
	end
	local localHero = CHero.GetLocal()
	local localAbilities = self:GetUsableAbilitiesToDisable(localHero, ability, enemy)
	if localAbilities[1] ~= nil then
		if self:IsInstantAbility(localAbilities[1]:GetName()) then
			delay = 0
		end
		local callback = function(self)
			self:UseAbility(localAbilities[1], enemy, ability)
		end
		if delay > 0 then
			timer.Barebones(delay, callback, self)
		else
			callback(self)
		end
	else
		local localPlayerID = CPlayer.GetLocal():GetPlayerID()
		for _, hero in pairs(CHeroes.GetAlliesOnly()) do
			if hero:IsControllableByPlayer(localPlayerID) then
				local abilities = self:GetUsableAbilitiesToDisable(hero, ability, enemy)
				if abilities[1] ~= nil then
					if self:IsInstantAbility(abilities[1]:GetName()) then
						delay = 0
					end
					local callback = function(self)
						self:UseAbility(abilities[1], enemy, ability)
					end
					if delay > 0 then
						timer.Barebones(delay, callback, self)
					else
						callback(self)
					end
					break
				end
			end
		end
	end
end

function AutoDisablerExtended:UseAbility(ability, enemy, enemy_ability)
	local hero = ability:GetCaster()
	local ability_name = ability:GetName()
	local linken_breaker = self:GetLinkenBreakerForDisableAbility(ability_name)
	local callback = function(this)
		return function(isLinkenFree)
			if not isLinkenFree then return end
			ability:Cast(enemy)
			this:SendNotification(ability, enemy_ability, enemy)
		end
	end
	if hero:IsChannellingAbility() then
		hero:Stop()
	end
	if linken_breaker ~= nil then
		LinkenBreaker:break_linken(hero, enemy, linken_breaker, nil, ability_name, callback(self))
	else
		callback(self)(true)
	end
end

function AutoDisablerExtended:SendNotification(disable_ability, trigger_ability, enemy)
	if self.auto_disabler_notifications:get_value() then
		local disablerName = disable_ability:GetCaster():GetUnitName()
		local enemyName = enemy:GetUnitName()
		if self.loaded_icons[disablerName] == nil then
			self.loaded_icons[disablerName] = Renderer.LoadImage("panorama/images/heroes/icons/"..disablerName.."_png.vtex_c")
		end
		if self.loaded_icons[enemyName] == nil then
			self.loaded_icons[enemyName] = Renderer.LoadImage("panorama/images/heroes/icons/"..enemyName.."_png.vtex_c")
		end
		if trigger_ability ~= nil then
			Renderer.DrawCenteredNotification("{#FF0000}[{&"..self.loaded_icons[enemyName].."}{#FF0000}]{&"..self.loaded_icons[trigger_ability:GetName(true)].."} {#CF4646}disabled by {#00FF00}[{&"..self.loaded_icons[disablerName].."}{#00FF00}]{&"..self.loaded_icons[disable_ability:GetName()].."}", 2)
		else
			Renderer.DrawCenteredNotification("{#FF0000}[{&"..self.loaded_icons[enemyName].."}{#FF0000}]{&"..self.loaded_icons["aggressive_disable"].."} {#CF4646}aggressive disabled by {#00FF00}[{&"..self.loaded_icons[disablerName].."}{#00FF00}]{&"..self.loaded_icons[disable_ability:GetName()].."}", 2)
		end
	end
end

function AutoDisablerExtended:OnMenuOptionChange(option, oldValue, newValue)
	if option == self.auto_disabler_enable.menu_option then
		if self:IsEnabled() then
			self.listeners["AbilityUsageHeroEnemy"] = true
			self.listeners["HeroVisibilityEnemy"] = true
		else
			self.listeners["AbilityUsageHeroEnemy"] = nil
			self.listeners["HeroVisibilityEnemy"] = nil
		end
	elseif option == self.auto_disabler_min_delay.menu_option then
		local max_delay = self.auto_disabler_max_delay:get_value()
		if newValue > max_delay then
			self.auto_disabler_min_delay:set_value(max_delay)
		end
	elseif option == self.auto_disabler_max_delay.menu_option then
		local min_delay = self.auto_disabler_min_delay:get_value()
		if min_delay > newValue then
			self.auto_disabler_min_delay:set_value(newValue)
		end
	end
end

ScriptAPI.Init(AutoDisablerExtended)

return ScriptAPI