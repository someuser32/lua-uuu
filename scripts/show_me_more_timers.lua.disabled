require("libraries/__init__")

local ShowMeMoreTimers = class("ShowMeMoreTimers")

function ShowMeMoreTimers:initialize()
	self.path = {"Magma", "Info Screen", "Show Me More"}

	self.enable = UILib:CreateCheckbox(self.path, "Show Abilities lifetime", false)
	self.enable:SetIcon("~/MenuIcons/Time/sand_time.png")

	self.allowed_thinkers = {
		"modifier_alchemist_acid_spray_thinker",
	}

	self.drawings = {}

	self.listeners = {}
end

function ShowMeMoreTimers:OnDraw()
	if not self.enable:Get() then return end
	local now = CGameRules:GetGameTime()
	for _, drawing in pairs(table.copy(self.drawings)) do
		if drawing[1] > now then
			-- CRenderer
		else
			table.remove(self.drawings, _)
		end
	end
end

function ShowMeMoreTimers:OnParticleCreate(particle)
	-- print("----------------\ncreate")
	-- DeepPrintTable(particle)
	-- local particle_info = self.particles_info[particle["fullName"]] or self.particles_info[particle["name"]]
	-- if particle_info == nil then return end
	-- local owner = nil
	-- if particle["entityForModifiers"] ~= nil then
	-- 	owner = CNPC:new(particle["entityForModifiers"])
	-- end
	-- if owner == nil and particle_info["ability"] ~= nil then
	-- 	for _, enemy in pairs(CHero:GetEnemies()) do
	-- 		local ability = enemy:GetAbilityOrItemByName(particle_info["ability"])
	-- 		if ability ~= nil then
	-- 			owner = enemy
	-- 			break
	-- 		end
	-- 	end
	-- end
	-- if owner == nil and particle["entity_id"] ~= nil and particle["entity_id"] ~= -1 then
	-- 	owner = CNPC:new(particle["entity_id"])
	-- end
	-- if owner == nil or owner:GetTeamNum() == CPlayer:GetLocalTeam() then return end
	-- self.particles[particle["index"]] = {
	-- 	start=CGameRules:GetGameTime(),
	-- 	name=particle["name"],
	-- 	fullname=particle["fullName"],
	-- 	owner=owner,
	-- }
end

function ShowMeMoreTimers:OnParticleUpdate(particle)
	-- print("----------------\nupdate")
	-- DeepPrintTable(particle)
	-- local create_info = self.particles[particle["index"]]
	-- if create_info == nil then return end
	-- local particle_info = self.particles_info[create_info["fullName"]] or self.particles_info[create_info["name"]]
	-- for _, key in pairs({"start_position", "speed", "position", "radius"}) do
	-- 	if type(particle_info[key]) == "string" then
	-- 		local controlPoint, coordinates = table.unpack(string.split(particle_info[key], "-"))
	-- 		if particle["controlPoint"] == tonumber(controlPoint) then
	-- 			local coordinates_table = string.split(coordinates, "")
	-- 			if #coordinates_table == 1 then
	-- 				self.particles[particle["index"]][key] = particle["position"][coordinates_table[1]]
	-- 			else
	-- 				local vec = {}
	-- 				for _, coord in pairs(coordinates_table) do
	-- 					vec[coord] = particle["position"][coord]
	-- 				end
	-- 				self.particles[particle["index"]][key] = Vector(vec["x"] or 0, vec["y"] or 0, vec["z"] or 0)
	-- 			end
	-- 		end
	-- 	elseif type(particle_info[key]) == "function" then
	-- 		self.particles[particle["index"]][key] = particle_info[key](create_info["owner"], self.particles[particle["index"]])
	-- 	elseif type(particle_info[key]) == "number" then
	-- 		self.particles[particle["index"]][key] = particle_info[key]
	-- 	end
	-- end
	-- create_info = self.particles[particle["index"]]
	-- if create_info["start_position"] ~= nil and create_info["speed"] ~= nil and create_info["position"] ~= nil and create_info["radius"] ~= nil then
	-- 	local duration = (create_info["position"] - create_info["start_position"]):Length2D() / create_info["speed"]
	-- 	self:DrawAlert(particle_info["alert"], create_info["position"], create_info["radius"], duration)
	-- 	self.particles["index"] = nil
	-- end
end

function ShowMeMoreTimers:OnParticleUpdateEntity(particle)
	-- print("----------------\nupdate ent")
	-- DeepPrintTable(particle)
	-- local create_info = self.particles[particle["index"]]
	-- if create_info == nil then return end
	-- local particle_info = self.particles_info[create_info["fullName"]] or self.particles_info[create_info["name"]]
	-- for _, key in pairs({"start_position", "speed", "position", "radius"}) do
	-- 	if type(particle_info[key]) == "string" then
	-- 		local controlPoint, coordinates = table.unpack(string.split(particle_info[key], "-"))
	-- 		if particle["controlPoint"] == tonumber(controlPoint) then
	-- 			local coordinates_table = string.split(coordinates, "")
	-- 			if #coordinates_table == 1 then
	-- 				self.particles[particle["index"]][key] = particle["position"][coordinates_table[1]]
	-- 			else
	-- 				local vec = {}
	-- 				for _, coord in pairs(coordinates_table) do
	-- 					vec[coord] = particle["position"][coord]
	-- 				end
	-- 				self.particles[particle["index"]][key] = Vector(vec["x"] or 0, vec["y"] or 0, vec["z"] or 0)
	-- 			end
	-- 		end
	-- 	elseif type(particle_info[key]) == "function" then
	-- 		self.particles[particle["index"]][key] = particle_info[key](create_info["owner"], self.particles[particle["index"]])
	-- 	elseif type(particle_info[key]) == "number" then
	-- 		self.particles[particle["index"]][key] = particle_info[key]
	-- 	end
	-- end
	-- create_info = self.particles[particle["index"]]
	-- if create_info["start_position"] ~= nil and create_info["speed"] ~= nil and create_info["position"] ~= nil and create_info["radius"] ~= nil then
	-- 	local duration = (create_info["position"] - create_info["start_position"]):Length2D() / create_info["speed"]
	-- 	self:DrawAlert(particle_info["alert"], create_info["position"], create_info["radius"], duration)
	-- 	self.particles["index"] = nil
	-- end
end

function ShowMeMoreTimers:OnModifierCreate(ent, mod)
	local npc = CNPC:new(ent)
	local modifier = CModifier:new(mod)
	if table.contains(self.allowed_thinkers, modifier:GetName()) then
		local now = CGameRules:GetGameTime()
		table.insert(self.drawings, {now+modifier:GetDuration(), npc:GetAbsOrigin(), modifier:GetAbility():GetName()})
	end
	-- if ent:IsNPC() then
	-- 	local npc = CNPC:new(entity)
	-- end
end

function ShowMeMoreTimers:OnLinearProjectileCreate(projectile)
	-- print("----------------\nprojectile")
	-- DeepPrintTable(projectile)
end

return BaseScriptAPI(ShowMeMoreTimers)